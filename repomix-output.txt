This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-30T10:03:37.789Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
customer.dart
payment.dart
plan.dart
sync_status.dart

================================================================
Files
================================================================

================
File: customer.dart
================
import 'dart:math';
import 'package:isar/isar.dart';
import 'plan.dart';
part 'customer.g.dart';
@Collection(inheritance: false)
class Customer {
  Id id = Isar.autoIncrement;
  @Index(type: IndexType.value)
  String name;
  String contact;
  bool isActive;
  @Index(type: IndexType.value)
  String wifiName;
  String currentPassword;
  DateTime subscriptionStart;
  DateTime subscriptionEnd;
  @Index(type: IndexType.value)
  DateTime lastModified;
  @Enumerated(EnumType.name)
  PlanType planType;
  Customer({
    required this.name,
    required this.contact,
    required this.isActive,
    required this.wifiName,
    required this.currentPassword,
    required this.subscriptionStart,
    required this.subscriptionEnd,
    required this.planType,
  }) : lastModified = DateTime.now();
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'contact': contact,
      'isActive': isActive,
      'wifiName': wifiName,
      'currentPassword': currentPassword,
      'subscriptionStart': subscriptionStart.toIso8601String(),
      'subscriptionEnd': subscriptionEnd.toIso8601String(),
      'lastModified': lastModified.toIso8601String(),
      'planType': planType.name,
    };
  }
  static Customer fromJson(Map<String, dynamic> json) {
    return Customer(
        name: json['name'] as String,
        contact: json['contact'] as String,
        isActive: json['isActive'] as bool,
        wifiName: json['wifiName'] as String,
        currentPassword: json['currentPassword'] as String,
        subscriptionStart: DateTime.parse(json['subscriptionStart'] as String),
        subscriptionEnd: DateTime.parse(json['subscriptionEnd'] as String),
        planType: PlanType.values.firstWhere(
          (e) => e.name == json['planType'],
          orElse: () => PlanType.daily,
        ),
      )
      ..id = json['id'] as int
      ..lastModified = DateTime.parse(json['lastModified'] as String);
  }
  Customer copyWith({
    String? name,
    String? contact,
    bool? isActive,
    String? wifiName,
    String? currentPassword,
    DateTime? subscriptionStart,
    DateTime? subscriptionEnd,
    PlanType? planType,
  }) {
    return Customer(
      name: name ?? this.name,
      contact: contact ?? this.contact,
      isActive: isActive ?? this.isActive,
      wifiName: wifiName ?? this.wifiName,
      currentPassword: currentPassword ?? this.currentPassword,
      subscriptionStart: subscriptionStart ?? this.subscriptionStart,
      subscriptionEnd: subscriptionEnd ?? this.subscriptionEnd,
      planType: planType ?? this.planType,
    )..id = id;
  }
  static const int _minLength = 4;
  static const int _maxSingleWordLength = 6;
  static const int _minRandomSuffix = 100;
  static const int _maxRandomSuffix = 999;
  static String generateWifiName(String? customerName) {
    if (customerName == null || customerName.trim().isEmpty) {
      throw ArgumentError('Customer name cannot be null or empty');
    }
    final cleanName = customerName
        .trim()
        .replaceAll(RegExp(r'[^\w\s]'), '')
        .replaceAll(RegExp(r'\s+'), ' ');
    // Split into words and filter out empty strings
    final words =
        cleanName.split(' ').where((word) => word.isNotEmpty).toList();
    if (words.isEmpty) {
      throw ArgumentError('Customer name contains no valid characters');
    }
    String wifiName;
    if (words.length == 1) {
      wifiName = _generateSingleWordName(words[0]);
    } else {
      wifiName = _generateMultiWordName(words);
    }
    if (wifiName.length < _minLength) {
      wifiName += _generateRandomSuffix();
    }
    return wifiName.toUpperCase();
  }
  static String _generateSingleWordName(String word) {
    if (word.length <= _maxSingleWordLength) {
      return word;
    }
    return word.substring(0, _maxSingleWordLength);
  }
  static String _generateMultiWordName(List<String> words) {
    return words.where((word) => word.isNotEmpty).map((word) => word[0]).join();
  }
  static String _generateRandomSuffix() {
    final random =
        DateTime.now().millisecondsSinceEpoch %
            (_maxRandomSuffix - _minRandomSuffix) +
        _minRandomSuffix;
    return random.toString();
  }
  static const String _upperCaseLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  static const String _lowerCaseLetters = 'abcdefghijklmnopqrstuvwxyz';
  static const String _numbers = '0123456789';
  static const String _specialCharacters = '!@#\$%^&*()-_=+';
  static const int _defaultLength = 12;
  static const int _minLengthx = 8;
  static const int _maxLength = 128;
  static String generate({
    int length = _defaultLength,
    bool useSpecialChars = false,
    bool useLowerCase = true,
    bool useNumbers = true,
  }) {
    if (length < _minLengthx || length > _maxLength) {
      throw ArgumentError(
        'Password length must be between $_minLengthx and $_maxLength characters',
      );
    }
    final charPool = StringBuffer(_upperCaseLetters);
    if (useLowerCase) charPool.write(_lowerCaseLetters);
    if (useNumbers) charPool.write(_numbers);
    if (useSpecialChars) charPool.write(_specialCharacters);
    final String chars = charPool.toString();
    if (chars.isEmpty) {
      throw ArgumentError('At least one character set must be enabled');
    }
    final random = Random.secure();
    final password = StringBuffer();
    if (useSpecialChars) {
      password.write(
        _specialCharacters[random.nextInt(_specialCharacters.length)],
      );
    }
    if (useLowerCase) {
      password.write(
        _lowerCaseLetters[random.nextInt(_lowerCaseLetters.length)],
      );
    }
    if (useNumbers) {
      password.write(_numbers[random.nextInt(_numbers.length)]);
    }
    password.write(_upperCaseLetters[random.nextInt(_upperCaseLetters.length)]);
    final remainingLength = length - password.length;
    for (var i = 0; i < remainingLength; i++) {
      password.write(chars[random.nextInt(chars.length)]);
    }
    final passwordChars = password.toString().split('');
    passwordChars.shuffle(random);
    return passwordChars.join();
  }
  /// Checks if a password meets minimum strength requirements.
  ///
  /// Returns:
  ///   true if password meets all requirements, false otherwise
  static bool isStrong(String password) {
    if (password.length < _minLengthx) return false;
    final hasUpperCase = password.contains(RegExp(r'[A-Z]'));
    final hasLowerCase = password.contains(RegExp(r'[a-z]'));
    final hasNumbers = password.contains(RegExp(r'[0-9]'));
    final hasSpecialChars = password.contains(RegExp(r'[!@#\$%^&*()-_=+]'));
    return hasUpperCase && hasLowerCase && hasNumbers && hasSpecialChars;
  }
}

================
File: payment.dart
================
import 'package:isar/isar.dart';
import 'plan.dart';
part 'payment.g.dart';
@Collection(inheritance: false)
class Payment {
  Id id = Isar.autoIncrement;
  @Index(type: IndexType.value)
  DateTime paymentDate;
  double amount;
  String customerId;
  @Enumerated(EnumType.name)
  PlanType planType;
  bool isConfirmed;
  @Index(type: IndexType.value)
  DateTime lastModified;
  Payment({
    required this.paymentDate,
    required this.amount,
    required this.customerId,
    required this.planType,
    this.isConfirmed = false,
  }) : lastModified = DateTime.now();
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'paymentDate': paymentDate.toIso8601String(),
      'amount': amount,
      'customerId': customerId,
      'planType': planType.name,
      'isConfirmed': isConfirmed,
      'lastModified': lastModified.toIso8601String(),
    };
  }
  static Payment fromJson(Map<String, dynamic> json) {
    return Payment(
      paymentDate: DateTime.parse(json['paymentDate'] as String),
      amount: json['amount'] as double,
      customerId: json['customerId'] as String,
      planType: PlanType.values.firstWhere(
        (e) => e.name == json['planType'],
        orElse: () => PlanType.daily,
      ),
      isConfirmed: json['isConfirmed'] as bool,
    )
      ..id = json['id'] as int
      ..lastModified = DateTime.parse(json['lastModified'] as String);
  }
  Payment copyWith({
    DateTime? paymentDate,
    double? amount,
    String? customerId,
    PlanType? planType,
    bool? isConfirmed,
  }) {
    return Payment(
      paymentDate: paymentDate ?? this.paymentDate,
      amount: amount ?? this.amount,
      customerId: customerId ?? this.customerId,
      planType: planType ?? this.planType,
      isConfirmed: isConfirmed ?? this.isConfirmed,
    )..id = id;
  }
}

================
File: plan.dart
================
import 'package:isar/isar.dart';
part 'plan.g.dart';
@Enumerated(EnumType.name)
enum PlanType {
  daily,
  weekly,
  monthly
}
@Collection()
class Plan {
  Id id = Isar.autoIncrement;
  @Enumerated(EnumType.name)
  PlanType type;
  double price;
  int durationInDays;
  Plan({
    required this.type,
    required this.price,
    required this.durationInDays,
  });
}

================
File: sync_status.dart
================
import 'package:isar/isar.dart';
part 'sync_status.g.dart';
@collection
class SyncStatus {
  Id id = Isar.autoIncrement;
  @Index(type: IndexType.value)
  final int entityId;
  @Index(type: IndexType.value)
  final String entityType;
  @Index(type: IndexType.value)
  final String operation;
  final DateTime timestamp;
  SyncStatus({
    required this.entityId,
    required this.entityType,
    required this.operation,
    required this.timestamp,
  });
}
